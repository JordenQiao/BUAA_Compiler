const int _GLOBAL_MAX_NUM 128 
function int factorial  
para int n  
cmp n <= 1 
BZ label_0   
return 1 factorial  
label label_0   
use factorial   
- n 1 $2 
push $2   
call factorial   
* n RET $3 
return $3 factorial  
function int mod  
para int x  
para int y  
/ x y $6 
* $6 y $7 
- x $7 x 
return x mod  
function void swap  
para int x  
para int y  
var int temp  
printf 0 int x 
printf  char '\n' 
printf 1 int y 
printf  char '\n' 
= temp x  
= x y  
= y temp  
printf 2 int x 
printf  char '\n' 
printf 3 int y 
printf  char '\n' 
return  swap  
function int full_num  
para int n  
para int j  
para int a  
* n 100 $9 
* j 10 $11 
+ $9 $11 $12 
+ $12 a $13 
return $13 full_num  
function int flower_num  
para int n  
para int j  
para int a  
* n n $14 
* $14 n $15 
* j j $17 
* $17 j $18 
+ $15 $18 $19 
* a a $20 
* $20 a $21 
+ $19 $21 $22 
return $22 flower_num  
function void complete_flower_num  
var int k[128]  
var int i  
var int j  
var int n  
var int s  
var int x1  
var int y  
var int m  
var int k2  
var int h  
var int leap  
var int x2  
var int a  
var int b  
var int c  
= j 2  
label label_2   
cmp j < 128 
BZ label_3   
= n -1  
= s j  
= i 1  
label label_4   
cmp i < j 
BZ label_5   
/ j i $26 
* $26 i x1 
use mod   
push j   
push i   
call mod   
+ 0 RET $30 
cmp $30 == 0 
BZ label_6   
+ n 1 n 
- s i s 
cmp n >= 128 
BZ label_8   
printf 4 int  
printf  char '\n' 
GOTO label_9   
label label_8   
[]= n i k 
label label_9   
label label_6   
+ i 1 i 
GOTO label_4   
label label_5   
cmp s == 0 
BZ label_10   
printf 5 int j 
printf  char '\n' 
= i 0  
label label_12   
cmp i <= n 
BZ label_13   
[] k i $38 
printf 6 int $38 
printf  char '\n' 
+ i 1 i 
GOTO label_12   
label label_13   
printf 7 int  
printf  char '\n' 
label label_10   
+ j 1 j 
GOTO label_2   
label label_3   
printf 8 int  
printf  char '\n' 
printf 9 int  
printf  char '\n' 
= y 0  
= i 100  
label label_14   
cmp i < 228 
BZ label_15   
/ i 100 n 
use mod   
/ i 10 $45 
push $45   
push 10   
call mod   
+ 0 RET j 
use mod   
push i   
push 10   
call mod   
+ 0 RET a 
use full_num   
push n   
push j   
push a   
call full_num   
+ 0 RET $49 
use flower_num   
push n   
push j   
push a   
call flower_num   
+ 0 RET $50 
cmp $49 == $50 
BZ label_16   
[]= y i k 
+ y 1 y 
label label_16   
+ i 1 i 
GOTO label_14   
label label_15   
= i 0  
label label_18   
cmp i < y 
BZ label_19   
[] k i $54 
printf 10 int $54 
printf  char '\n' 
+ i 1 i 
GOTO label_18   
label label_19   
printf 11 int  
printf  char '\n' 
printf 12 int  
printf  char '\n' 
= h 0  
= leap 1  
= m 2  
label label_20   
cmp m <= 128 
BZ label_21   
/ m 2 k2 
= i 2  
label label_22   
cmp i <= k2 
BZ label_23   
/ m i $60 
* $60 i x2 
use mod   
push m   
push i   
call mod   
+ 0 RET $64 
cmp $64 == 0 
BZ label_24   
= leap 0  
label label_24   
+ i 1 i 
GOTO label_22   
label label_23   
cmp leap == 1 
BZ label_26   
printf 13 int m 
printf  char '\n' 
+ h 1 h 
/ h 10 $68 
* $68 10 x2 
cmp x2 == h 
BZ label_28   
printf 14 int  
printf  char '\n' 
label label_28   
label label_26   
= leap 1  
+ m 1 m 
GOTO label_20   
label label_21   
printf 15 int h 
printf  char '\n' 
return  complete_flower_num  
function void main  
var int n  
use factorial   
push 5   
call factorial   
+ 0 RET n 
printf 16 int n 
printf  char '\n' 
use swap   
push 5   
push 10   
call swap   
use complete_flower_num   
call complete_flower_num   
end    
